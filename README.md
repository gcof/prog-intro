---
gitea: none
include_toc: true
---

# Тесты к курсу «Введение в программирование»

[Условия домашних заданий](https://www.kgeorgiy.info/courses/prog-intro/homeworks.html)

[Правила сдачи зачёта](test-rules.md)


## Домашнее задание 15. Вычисление в различных типах

Модификации
 * *Base*
    * Класс `GenericTabulator` должен реализовывать интерфейс
      [Tabulator](java/expression/generic/Tabulator.java) и
      строить трехмерную таблицу значений заданного выражения.
        * `mode` – режим вычислений:
           * `i` – вычисления в `int` с проверкой на переполнение;
           * `d` – вычисления в `double` без проверки на переполнение;
           * `bi` – вычисления в `BigInteger`.
        * `expression` – выражение, для которого надо построить таблицу;
        * `x1`, `x2` – минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` – аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать
          значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`.
          Если значение не определено (например, по причине переполнения),
          то соответствующий элемент должен быть равен `null`.
    * [Исходный код тестов](java/expression/generic/GenericTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *Parens* (32-42)
    * Дополнительно реализуйте поддержку квадратных и фигурных скобок:
        * `([{1 + 2} * 3] + 5)` равно 14;
        * скобки должны быть парными, `(1 + 2]` — ошибка.
 * *Ul* (34, 35)
     * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `l` – вычисления в `long` без проверки на переполнение.
 * *Asm* (36-42)
    * Дополнительно реализуйте унарные операции:
        * `abs` – модуль числа, `abs -5` равно 5;
        * `square` – возведение в квадрат, `square 5` равно 25.
    * Дополнительно реализуйте бинарную операцию (максимальный приоритет):
        * `mod` – взятие по модулю, приоритет как у умножения (`1 + 5 mod 3` равно `1 + (5 mod 3)` равно `3`).
 * *AsmUl* (36, 37)
    * Реализуйте операции из модификации *Asm*.
    * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `l` – вычисления в `long` без проверки на переполнение.
 * *AsmIf* (38, 39)
    * Реализуйте операции из модификации *Asm*.
    * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `if` – вычисления с фиксированной точкой (сдвиг 16 бит) в `int` 
          без проверки на переполнение.
 * *AsmLf* (41, 42)
    * Реализуйте операции из модификации *Asm*.
    * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `lf` – вычисления с фиксированной точкой (сдвиг 16 бит) в `long` 
          без проверки на переполнение.


## Домашнее задание 14. Обработка ошибок

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [TripleParser](java/expression/exceptions/TripleParser.java).
    * Результат разбора должен реализовывать интерфейс
        [TripleExpression](java/expression/TripleExpression.java)
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
    * [Исходный код тестов](java/expression/exceptions/ExceptionsTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *LastVars* (32-42)
    * Имя переменной – идентификатор, последняя буква которого 
      определяет реальную переменную (`x`, `y` или `z`).
 * *GcdLcm* (36-42)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `gcd` – НОД, `2 gcd -3` равно 1;
        * `lcm` – НОК, `2 lcm -3` равно -6.
 * *²Square* (36-39)
    * Дополнительно реализуйте унарные операции:
      * `n²` – возведение в квадрат, `-5²` равно 25;
      * `²n` – `n^n`, `²5` равно 3125.
 * *³Cube* (38, 39)
    * Дополнительно реализуйте унарные операции:
      * `n³` – возведение в куб, `-5³` равно −125;
      * `³n` – `n^(n^n)`, `³2` равно 16.
 * *Factorials* (41, 42)
    * Дополнительно реализуйте унарные операции:
      * `n!` – факториал, `5!` равен 120;
      * `!n` – максимальное число, факториал которого не превышает `n`, `!20` равен 3, `!-20` равен 0.
 * *Geom* (32-35)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `◣` – площадь прямоугольного треугольника по двум катетам, `5 ◣ 3` равно 7;
        * `▯` – периметр прямоугольника по двум сторонам, `4 ▯ 3` равно 14.
 * *Sqrt* (34, 35)
    * Дополнительно реализуйте унарную операцию
        * `√` – квадратный корень, `√24` равно 4.


## Домашнее задание 13. Разбор выражений

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [TripleParser](java/expression/parser/TripleParser.java)
    * Результат разбора должен реализовывать интерфейс
        [TripleExpression](java/expression/TripleExpression.java)
    * [Исходный код тестов](java/expression/parser/ParserTest.java)
        * Первый аргумент: `easy` или `hard`.
        * Последующие аргументы: модификации.
 * *LastVars* (32-42)
    * Имя переменной – идентификатор, последняя буква которого 
      определяет реальную переменную (`x`, `y` или `z`).
 * *PowLog* (36-42)
    * Дополнительно реализуйте бинарные операции (максимальный приоритет):
        * `**` – возведение в степень, `2 ** 3` равно 8, `2 ** -3` равно 1;
        * `//` – логарифм, `10 // 2` равно 3, `10 // -2` равно `-10 // 2` равно 0.
 * *Square* (36-39)
    * Дополнительно реализуйте унарную операцию
      `²` – возведение в квадрат, `-5²` равно 25.
 * *Cube* (38, 39)
    * Дополнительно реализуйте унарную операцию
      `³` – возведение в куб, `-5³` равно −125.
 * *Factorial* (41, 42)
    * Дополнительно реализуйте унарную операцию
      `!` – факториал абсолютного значения, `-5!` равно 120, `- 5!` равно -120.
 * *Sqrt* (34, 35)
    * Дополнительно реализуйте унарную операцию
        * `√` – квадратный корень, `√24` равно 4.
 * *Cbrt* (32, 33)
    * Дополнительно реализуйте унарную операцию
        * `∛` – кубический корень, `∛-123` равно -4.


## Домашнее задание 12. Выражения

Модификации
 * *Base*
    * Реализуйте интерфейс [Expression](java/expression/Expression.java)
    * [Исходный код тестов](java/expression/ExpressionTest.java)
        * Первый аргумент: `easy` или `hard`.
        * Последующие аргументы: модификации.
 * *Triple* (32-42)
    * Дополнительно реализуйте поддержку выражений с тремя переменными: `x`, `y` и `z`.
      * Например, для `expr = new Subtract(new Add(new Variable("x"), new Variable("y")), new Const(1))`:
        * `expr.evaluate(2, 3, 5)` должно быть равно 4;
        * `expr.toString()` должно быть равно `((x + y) - 1)`.
    * Интерфейс/тесты [TripleExpression](java/expression/TripleExpression.java).
 * *LongMap* (36, 37)
    * Дополнительно реализуйте поддержку выражений с произвольными переменными.
      * Имена переменных — произвольные идентификаторы.
      * Метод должен называться `evaluateL`.
        * Например, для `expr = new Subtract(new Add(new Variable("xx"), new Variable("yy")), new Const(1L))`:
          * `expr.evaluateL(Map.of("yy", 2L, "xx", 3L))` должно быть равно 4;
          * `expr.toString()` должно быть равно `((xx + yy) - 1)`.
    * Интерфейс/тесты [LongMapExpression](java/expression/LongMapExpression.java).
 * *DoubleMap* (38, 39)
    * Дополнительно реализуйте поддержку выражений с произвольными переменными.
      * Имена переменных — произвольные идентификаторы.
      * Метод должен называться `evaluateD`.
      * Например, для `expr = new Subtract(new Add(new Variable("xx"), new Variable("yy")), new Const(1.1))`:
        * `expr.evaluateD(Map.of("xx", 2.1, "yy", 3.1))` должно быть равно 4.1;
        * `expr.toString()` должно быть равно `((xx + yy) - 1.1)`.
    * Интерфейс/тесты [DoubleMapExpression](java/expression/DoubleMapExpression.java).
 * *FloatMap* (41, 42)
    * Дополнительно реализуйте поддержку выражений с произвольными переменными.
      * Имена переменных — произвольные идентификаторы.
      * Метод должен называться `evaluateF`.
      * Например, для `expr = new Subtract(new Add(new Variable("xx"), new Variable("yy")), new Const(1.1f))`:
        * `expr.evaluatef(Map.of("xx", 2.1f, "yy", 3.1f))` должно быть равно 4.1;
        * `expr.toString()` должно быть равно `((xx + yy) - 1.1)`.
    * Интерфейс/тесты [FloatMapExpression](java/expression/FloatMapExpression.java).
 * *LongTriple* (34, 35)
    * Сделайте модификацию *Triple* для вычислений в типе `long`.
      * Метод должен называться `evaluateL`.
      * Например, для `expr = new Subtract(new Add(new Variable("x"), new Variable("y")), new Const(1L))`:
        * `expr.evaluateL(2L, 3L, 5L)` должно быть равно 4;
        * `expr.toString()` должно быть равно `((x + y) - 1)`.
    * Интерфейс/тесты [LongTripleExpression](java/expression/LongTripleExpression.java).


## Домашнее задание 11. Игра m,n,k

Решение должно находиться в пакете `game`.

Модификации
 * *Базовая*
    * Тестов не существует, так как они зависят от вашего кода.
 * *Ромб* (32-42)
    * Добавьте поддержку доски в форме ромба (квадрата, повернутого на 45°).
    * В качестве примера, сделайте доску размером 10×10.
 * *Дебютный регламент* (34-37)
    * Первые _p_ полуходов должны быть в центральном прямоугольнике
      размера (_a_ + 2 _i_)×(_b_ + 2 _i_),
      где _i_ — номер полухода, _a_ = − _m_ % 2, _b_ = − _n_ % 2.
 * *Переговоры* (38-42)
    * У игрока должна быть возможность сдаться, если он не хочет продолжать игру.
    * Игрок может вместо своего хода предложить ничью.
      Если второй игрок принимает предложение, то игра заканчивается.
      В противном случае, игра продолжается и игрок делает ход.
      Повторное предложение ничьей на том же ходу считается ошибкой.
 * *Double Elimination* (36-39)
    * Добавьте поддержку турниров
      [с выбыванием после двух поражений](https://ru.wikipedia.org/wiki/Турнирная_система_с_выбыванием_после_двух_поражений)
      с правилом 1-2.
    * Игроки и их символы в матче выбираются случайно.
    * При ничьей игроки играют до результативной партии.
    * Выбывшие на одном круге делят одно место.
    * Если игроков не степень двойки, то часть из них проходит во второй круг без игры.
 * *Швейцарская система* (41, 42)
    * Добавьте поддержку турниров по
      [швейцарской системе](https://ru.wikipedia.org/wiki/Швейцарская_система).
    * Символы игроков в матче выбираются случайно,
      правила о чередовании и последовательности цветов не действуют.
    * log₂ _n_ с округлением вверх туров, где _n_ — число игроков.
    * Участники набравшие равное число очков делят место.


## Домашнее задание 9. Markdown to HTML

Модификации
 * *Базовая*
    * [Исходный код тестов](java/md2html/Md2HtmlTester.java)
    * [Откомпилированные тесты](artifacts/Md2HtmlTest.jar)
        * Аргументы командной строки: модификации
 * *Image* (36, 37)
    * Добавьте поддержку ```![картинок](https://www.ifmo.ru/images/menu/small/p10.jpg)```:
        ```<img alt='картинок' src='https://www.ifmo.ru/images/menu/small/p10.jpg'>```
 * *Link* (38, 39)
    * Добавьте поддержку ```[ссылок с _выделением_]<https://kgeorgiy.info>```:
        ```<a href='https://kgeorgiy.info'>ссылок с <em>выделением</em></a>```
 * *InsDel* (41, 42)
    * Добавьте поддержку
        `<<вставок>>`: `<ins>вставок</ins>` и
        `}}удалений{{`: `<del>удалений</del>`
 * *Underline* (34, 35)
    * Добавьте поддержку `++подчеркивания++`: `<u>подчеркивания</u>`
 * *Mark* (32, 33)
    * Добавьте поддержку `~выделения цветом~`: `<mark>выделения цветом</mark>`


## Домашнее задание 7. Разметка

Модификации
 * *Base*
    * Исходный код тестов:
        * [MarkupTester.java](java/markup/MarkupTester.java)
        * [MarkupTest.java](java/markup/MarkupTest.java)
        * Аргументы командной строки: модификации
    * Откомпилированных тестов не существует,
      так как они зависят от вашего кода
 * *DocBookList* (36-39, 41, 42)
    * Дополнительно реализуйте метод `toDocBook`, генерирующий [DocBook](https://docbook.org/)-разметку:
      * Абзацы окружаются тегом `para`
      * Выделенный текст окружается тегом `emphasis`
      * Сильно выделенный текст окружается тегом `emphasis` с `role='bold'`
      * Зачеркнутый текст окружается тегом `emphasis` с `role='strikeout'`
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, тег `orderedlist`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, тег `itemizedlist`): последовательность элементов
      * Элементов списка (класс `ListItem`, тег `listitem`): последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
    * [Исходный код тестов](java/markup/MarkupListTest.java)
 * *Typst* (32-35)
    * Дополнительно реализуйте метод `toTypst`,
      генерирующий [Typst](https://typst.app/docs/reference/)-разметку:
      * Выделенный текст заключается в `#emph[` и `]`
      * Сильно выделенный текст заключается в `#strong[` и `]`
      * Зачеркнутый текст заключается в `#strike[` и `]`


## Домашнее задание 6. Подсчет слов++

Модификации
 * *Base*
    * Класс должен иметь имя `Wspp`
    * Исходный код тестов:
        [WsppTest.java](java/wspp/WsppTest.java),
        [WsppTester.java](java/wspp/WsppTester.java)
    * Откомпилированные тесты: [WsppTest.jar](artifacts/WsppTest.jar)
        * Аргументы командной строки: модификации
 * *EvenDigits* (36, 37)
    * Вместо номеров вхождений во всем файле надо указывать
      только чётные вхождения в каждой строке
    * В словах могут дополнительно встречаться
      цифры
    * Класс должен иметь имя `WsppEvenDigits`
 * *CountEvenDigits* (38, 39)
    * В выходном файле слова должны быть упорядочены
      по возрастанию числа вхождений, а при равном числе вхождений –
      по порядку первого вхождения во входном файле
    * Вместо номеров вхождений во всем файле надо указывать
      только чётные вхождения в каждой строке
    * В словах могут дополнительно встречаться
      цифры
    * Класс должен иметь имя `WsppCountEvenDigits`
 * *EvenCurrency* (41, 42)
    * Вместо номеров вхождений во всем файле надо указывать
      только чётные вхождения в каждой строке
    * В словах могут дополнительно встречаться
      [знаки валют](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#CURRENCY_SYMBOL)
    * Класс должен иметь имя `WsppEvenCurrency`
 * *CountPosition* (34, 35)
    * В выходном файле слова должны быть упорядочены
      по возрастанию числа вхождений, а при равном числе вхождений –
      по порядку первого вхождения во входном файле
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppCountPosition`
 * *Position* (32, 33)
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppPosition`


## Домашнее задание 5. Свой сканнер

В этой домашней работе специальные тесты только для ДЗ-3.
Для ДЗ-4 используйте тесты от него.

Модификации
 * *Base*
    * Исходный код тестов: [FastReverseTest.java](java/reverse/FastReverseTest.java)
    * Откомпилированные тесты: [FastReverseTest.jar](artifacts/FastReverseTest.jar)
        * Аргументы командной строки: модификации
 * *MaxAbsOctDec* (36, 37)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите максимальное по абсолютному значению число
      в его столбце и строке
    * На вход подаются десятичные и восьмеричные числа
    * Восьмеричные числа имеют суффикс `o`
    * Выведите все числа, используя формат восьмеричных чисел
    * Класс должен иметь имя `ReverseMaxAbsOctDec`
 * *MaxModOctDec* (38, 39)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите максимальное по остатку от деления на `1_000_000_007`
      среди чисел в его столбце и строке
    * На вход подаются десятичные и восьмеричные числа
    * Восьмеричные числа имеют суффикс `o`
    * Выведите все числа, используя формат восьмеричных чисел
    * Класс должен иметь имя `ReverseMaxModOctDec`
 * *MaxAbsModOctDec* (41, 42)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите максимальное по остатку от деления на `1_000_000_007`
      абсолютного значения среди чисел в его столбце и строке
    * На вход подаются десятичные и восьмеричные числа
    * Восьмеричные числа имеют суффикс `o`
    * Выведите все числа, используя формат восьмеричных чисел
    * Класс должен иметь имя `ReverseMaxAbsModOctDec`
 * *MaxOct* (34, 35)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите максимум из чисел
      в его столбце и строке
    * Во вводе и выводе используются числа в восьмеричной системе счисления
    * Класс должен иметь имя `ReverseMaxOct`
 * *OddOct* (32, 33)
    * Выведите (в реверсивном порядке) только нечетные числа
    * Во вводе и выводе используются числа в восьмеричной системе счисления
    * Класс должен иметь имя `ReverseOddOct`


## Домашнее задание 4. Подсчет слов

Модификации
 * *Base*
    * Класс должен иметь имя `WordStatInput`
    * Исходный код тестов:
        [WordStatTest.java](java/wordStat/WordStatTest.java),
        [WordStatTester.java](java/wordStat/WordStatTester.java),
        [WordStatChecker.java](java/wordStat/WordStatChecker.java)
    * Откомпилированные тесты: [WordStatTest.jar](artifacts/WordStatTest.jar)
        * Аргументы командной строки: модификации
 * *FastSort* (36-42)
    * Пусть _n_ – число слов во входном файле,
      тогда программа должна работать за O(_n_ log _n_).
 * *WordsSuffix* (36, 37)
    * Выходной файл должен содержать все различные суффиксы длины 3
      слов, встречающихся во входном файле,
      в обратном лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsSuffix`
 * *WordsShingles* (38, 39)
    * Выходной файл должен содержать все различные подстроки длины 3
      слов, встречающихся во входном файле,
      в обратном лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsShingles`
 * *WordsMiddle* (41, 42)
    * Назовём _серединой слова_ подстроку, полученную удалением
      первых и последних 3 символов слова.
      Слова длины меньшей 7 используются как есть.
    * Выходной файл должен содержать все различные середины слов,
      встречающихся во входном файле,
      в обратном лексикографическом порядке.
    * Класс должен иметь имя `WordStatWordsMiddle`
 * *Words* (32, 33)
    * В выходном файле слова должны быть упорядочены
      в обратном лексикографическом порядке
    * Класс должен иметь имя `WordStatWords`
 * *WordsPrefix* (34, 35)
    * Выходной файл должен содержать все различные префиксы длины 3
      слов, встречающихся во входном файле,
      в обратном лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsPrefix`


## Домашнее задание 3. Реверс

Модификации
 * *Base*
    * Исходный код тестов:
        [ReverseTest.java](java/reverse/ReverseTest.java),
        [ReverseTester.java](java/reverse/ReverseTester.java)
    * Откомпилированные тесты: [ReverseTest.jar](artifacts/ReverseTest.jar)
        * Аргументы командной строки: модификации
 * *Memory* (36-42)
    * Программа должна сначала считывать все данные в память,
      и только потом обрабатывать их
    * Пусть _M_ – объём памяти, необходимый для сохранения ввода
      в двумерном массиве `int` минимального размера.
      Ваша программа должна использовать не более 4_M_ + 1024 байт памяти
    * Накладные расходы на запуск вашей программы JVM не учитываются
 * *SumAbs* (36, 37)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму абсолютных значений чисел
      в его столбце и строке
    * Класс должен иметь имя `ReverseSumAbs`
 * *SumMod* (38, 39)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите остаток от деления на `1_000_000_007` суммы чисел
      в его столбце и строке
    * Класс должен иметь имя `ReverseSumMod`
 * *SumAbsMod* (41, 42)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите остаток от деления на `1_000_000_007` суммы абсолютных значений чисел
      в его столбце и строке
    * Класс должен иметь имя `ReverseSumAbsMod`
 * *Odd* (32, 33)
    * Выведите (в реверсивном порядке) только нечетные числа
    * Класс должен иметь имя `ReverseOdd`
 * *Transpose* (34, 35)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      выведите только нечётные числа из её транспонированного вида
    * Класс должен иметь имя `ReverseTransp`


## Домашнее задание 2. Сумма чисел

Модификации
 * *Base*
    * Исходный код тестов:
        [SumTest.java](java/sum/SumTest.java),
        [SumTester.java](java/sum/SumTester.java),
        [базовые классы](java/base/)
    * Откомпилированные тесты: [SumTest.jar](artifacts/SumTest.jar)
        * Аргументы командной строки: модификации
 * *LongPunct* (36, 37)
    * Входные данные являются 64-битными целыми числами
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `SumLongPunct`
 * *BigIntegerPunct* (38, 39)
    * Входные данные помещаются в тип [BigInteger](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.html)
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `SumBigIntegerPunct`
 * *LongPunctHex* (41, 42)
    * Входные данные являются 64-битными целыми числами
    * Некоторые числа во вводе могут быть шестнадцатеричными.
      Они имеют префикс `0x` и являются беззнаковыми.
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `SumLongPunctHex`
 * *Float* (32, 33)
    * Входные данные являются 32-битными числами в формате с плавающей точкой
    * Класс должен иметь имя `SumFloat`
 * *FloatPunct* (34, 35)
    * Входные данные являются 32-битными числами в формате с плавающей точкой
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `SumFloatPunct`


Для того, чтобы протестировать программу:

 1. Скачайте откомпилированные тесты ([SumTest.jar](artifacts/SumTest.jar))
 1. Откомпилируйте `Sum.java`
 1. Проверьте, что создался `Sum.class`
 1. В каталоге, в котором находится `Sum.class`, выполните команду
    ```
       java -ea -jar <путь к SumTest.jar> Base
    ```
    * Например, если `SumTest.jar` находится в текущем каталоге, выполните команду
    ```
        java -ea -jar SumTest.jar Base
    ```
 1. Для ускорения отладки рекомендуется сделать скрипт, выполняющий шаги 2−4.



## Домашнее задание 1. Запусти меня!

Модификации
  * *RunMe*
    1. Скачайте исходный код [RunMe.java](java/RunMe.java).
    1. Создайте скрипт, компилирующий и запускающий `RunMe` из командной строки
       с выданными вам аргументами командной строки.
    1. Следуйте выведенной инструкции.

Рекомендации по выполнению модификации

1. Проверьте версию Java:
    1. Запустите `javac --version` и проверьте, что версия
       находится в диапазоне 17..22.
    1. Запустите `java --version` и проверьте, что версия
       такая же как и у `javac`.
1. Скачайте [RunMe.java](java/RunMe.java)
1. Откомпилируйте `RunMe.java`:
    1. Запустите `javac RunMe.java`
    1. Убедитесь, что компиляция завершилась без ошибок
    1. Проверьте, что появился `RunMe.class`
1. Запустите `RunMe`:
    1. Запустите `java RunMe [шесть] [слов] [пароля] [пришедшего] [на] [email]`
    1. При правильном исполнении вы должны получить ссылку.
       Если получено сообщение об ошибке — исправьте её и запустите повторно
    1. Зайдите по полученной ссылке и убедитесь, что она правильная
1. Напишите и протестируйте скрипт:
    1. Напишите скрипт, включающий команды компиляции и запуска.
       Если вы не умеете писать скрипты, воспользуйтесь одной из инструкций:
       [Windows](https://tutorialreference.com/batch-scripting/batch-script-files),
       [Linux](https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux/),
       [macOS](https://rowannicholls.github.io/bash/intro/myscript.html)
    1. Запустите и проверьте, что вы получили ту же ссылку, что и в предыдущем пункте
    1. Сдайте скрипт преподавателю
1. Вы можете получить больше плюсиков, модифицируя код `RunMe.java`
